package generator

import (
	"bytes"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/jmattheis/goverter/config"
)

type fileManager struct {
	Files map[string]*managedFile
}

type managedFile struct {
	Package string
	Initial *config.Converter
	Content *jen.File
}

func (m *fileManager) Get(c *config.Converter, workDirectory string) (*jen.File, error) {
	output := getOutputDir(c, workDirectory)

	f, ok := m.Files[output]
	if !ok {
		f = &managedFile{
			Package: c.OutputPackage,
			Initial: c,
		}

		parts := strings.SplitN(c.OutputPackage, ":", 2)

		switch len(parts) {
		case 2:
			f.Content = jen.NewFilePathName(parts[0], parts[1])
		case 1:
			f.Content = jen.NewFilePath(parts[0])
		default:
			panic("could not create file")
		}
		f.Content.HeaderComment("// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.")
		m.Files[output] = f
	}

	if f.Package != c.OutputPackage {
		return nil, fmt.Errorf("Error creating converters\n    %s\n    %s\nand\n    %s\n    %s\n\nCannot use different packages\n    %s\n    %s\nin the same output file:\n    %s",
			c.FileSource, c.Type, f.Initial.FileSource, f.Initial.Type, c.OutputPackage, f.Initial.OutputPackage, output)
	}

	return f.Content, nil
}

func (m *fileManager) renderFiles() (map[string][]byte, error) {
	result := map[string][]byte{}
	for name, f := range m.Files {
		var buf bytes.Buffer
		if err := f.Content.Render(&buf); err != nil {
			return result, err
		}
		result[name] = buf.Bytes()
	}
	return result, nil
}

func getOutputDir(c *config.Converter, cwd string) string {
	if strings.HasPrefix(c.OutputFile, "@cwd/") {
		return filepath.Join(cwd, strings.TrimPrefix(c.OutputFile, "@cwd/"))
	}
	return filepath.Join(filepath.Dir(c.FileSource), c.OutputFile)
}
