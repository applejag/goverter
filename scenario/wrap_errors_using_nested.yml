input:
    input.go: |
        package structs

        // goverter:converter
        // goverter:extend strconv:Atoi
        // goverter:wrapErrorsUsing github.com/jmattheis/goverter/execution/patherr
        type Converter interface {
            Convert(Input) (Output, error)
        }

        type Input struct {
            Values map[string]map[int]struct {Age string}
            S struct {Names []map[bool]string}
        }
        type Output struct {
            Values map[string]map[int]struct {Age int}
            S struct {Names []map[bool]int}
        }
    patherr/patherr.go: |
        package patherr

        func Key(any) any { return nil }
        func Index(int) any { return nil }
        func Field(string) any { return nil }
        func Wrap(error, ...any) error { return nil }
success:
    - generated/generated.go: |
        // Code generated by github.com/jmattheis/goverter, DO NOT EDIT.

        package generated

        import (
        	execution "github.com/jmattheis/goverter/execution"
        	patherr "github.com/jmattheis/goverter/execution/patherr"
        	"strconv"
        )

        type ConverterImpl struct{}

        func (c *ConverterImpl) Convert(source execution.Input) (execution.Output, error) {
        	var structsOutput execution.Output
        	var mapStringMapIntUnnamed map[string]map[int]struct {
        		Age int
        	}
        	if source.Values != nil {
        		mapStringMapIntUnnamed = make(map[string]map[int]struct {
        			Age int
        		}, len(source.Values))
        		for key, value := range source.Values {
        			var mapIntUnnamed map[int]struct {
        				Age int
        			}
        			if value != nil {
        				mapIntUnnamed = make(map[int]struct {
        					Age int
        				}, len(value))
        				for key2, value2 := range value {
        					var unnamed struct {
        						Age int
        					}
        					xint, err := strconv.Atoi(value2.Age)
        					if err != nil {
        						return structsOutput, patherr.Wrap(err, patherr.Field("Values"), patherr.Key(key), patherr.Key(key2), patherr.Field("Age"))
        					}
        					unnamed.Age = xint
        					mapIntUnnamed[key2] = unnamed
        				}
        			}
        			mapStringMapIntUnnamed[key] = mapIntUnnamed
        		}
        	}
        	structsOutput.Values = mapStringMapIntUnnamed
        	var unnamed2 struct {
        		Names []map[bool]int
        	}
        	var mapBoolIntList []map[bool]int
        	if source.S.Names != nil {
        		mapBoolIntList = make([]map[bool]int, len(source.S.Names))
        		for i := 0; i < len(source.S.Names); i++ {
        			var mapBoolInt map[bool]int
        			if source.S.Names[i] != nil {
        				mapBoolInt = make(map[bool]int, len(source.S.Names[i]))
        				for key3, value3 := range source.S.Names[i] {
        					xint2, err := strconv.Atoi(value3)
        					if err != nil {
        						return structsOutput, patherr.Wrap(err, patherr.Field("S"), patherr.Field("Names"), patherr.Index(i), patherr.Key(key3))
        					}
        					mapBoolInt[key3] = xint2
        				}
        			}
        			mapBoolIntList[i] = mapBoolInt
        		}
        	}
        	unnamed2.Names = mapBoolIntList
        	structsOutput.S = unnamed2
        	return structsOutput, nil
        }
